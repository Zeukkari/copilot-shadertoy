<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hello World! Hello GLSL!</title>
<link rel="stylesheet" href="style.css">

</head>
<body>
<p>Hello World! Hello GLSL!</p>
<canvas>Your browser does not seem to support HTML canvas.</canvas>
<div id="controls" class="controls-panel">
  <h3>Fractal Controls</h3>
  <div class="control-group">
    <label for="centerX">Center X:</label>
    <input type="range" id="centerX" min="-2" max="1" step="0.001" value="-0.5">
    <span class="value-display" id="centerXValue">-0.5</span>
  </div>
  <div class="control-group">
    <label for="centerY">Center Y:</label>
    <input type="range" id="centerY" min="-1.5" max="1.5" step="0.001" value="0.0">
    <span class="value-display" id="centerYValue">0.0</span>
  </div>
  <div class="control-group">
    <label for="zoom">Zoom:</label>
    <input type="range" id="zoom" min="0.1" max="20" step="0.001" value="1.0">
    <span class="value-display" id="zoomValue">1.0</span>
  </div>
  <div class="control-group">
    <label for="maxIterations">Max Iterations:</label>
    <input type="range" id="maxIterations" min="10" max="500" step="10" value="100">
    <span class="value-display" id="maxIterationsValue">100</span>
  </div>
  <div class="control-group">
    <label for="rotation">Rotation:</label>
    <input type="range" id="rotation" min="0" max="6.28" step="0.01" value="0.0">
    <span class="value-display" id="rotationValue">0.0</span>
  </div>
  <div class="control-group">
    <label for="escapeRadius">Escape Radius:</label>
    <input type="range" id="escapeRadius" min="2.0" max="10.0" step="0.1" value="4.0">
    <span class="value-display" id="escapeRadiusValue">4.0</span>
  </div>
  <div class="control-group">
    <label for="colorOffset">Color Offset:</label>
    <input type="range" id="colorOffset" min="0" max="6.28" step="0.1" value="0.0">
    <span class="value-display" id="colorOffsetValue">0.0</span>
  </div>
  <div class="control-group">
    <label for="colorSpeed">Color Speed:</label>
    <input type="range" id="colorSpeed" min="1" max="50" step="1" value="10">
    <span class="value-display" id="colorSpeedValue">10</span>
  </div>
  <div class="control-group">
    <label for="colorIntensity">Color Intensity:</label>
    <input type="range" id="colorIntensity" min="0.1" max="2.0" step="0.1" value="1.0">
    <span class="value-display" id="colorIntensityValue">1.0</span>
  </div>
  <div class="control-group">
    <label for="juliaMode">Julia Set Mode:</label>
    <input type="checkbox" id="juliaMode">
    <span class="value-display" id="juliaModeValue">Off</span>
  </div>
  <div class="control-group" id="juliaControls" style="display: none;">
    <label for="juliaX">Julia C X:</label>
    <input type="range" id="juliaX" min="-2" max="2" step="0.001" value="-0.7269">
    <span class="value-display" id="juliaXValue">-0.7269</span>
  </div>
  <div class="control-group" id="juliaControls2" style="display: none;">
    <label for="juliaY">Julia C Y:</label>
    <input type="range" id="juliaY" min="-2" max="2" step="0.001" value="0.1889">
    <span class="value-display" id="juliaYValue">0.1889</span>
  </div>
  <div class="control-group">
    <label for="colorPalette">Color Palette:</label>
    <select id="colorPalette">
      <option value="0">Rainbow</option>
      <option value="1">Fire</option>
      <option value="2">Ocean</option>
      <option value="3">Forest</option>
      <option value="4">Sunset</option>
      <option value="5">Monochrome</option>
    </select>
  </div>
  <button id="resetBtn" class="reset-btn">Reset to Default</button>
</div>
<script type="x-shader/x-vertex" id="vertex-shader">
  attribute vec2 a_position;
  varying vec2 v_uv;
  
  void main() {
    v_uv = a_position * 0.5 + 0.5; // Convert from -1..1 to 0..1
    gl_Position = vec4(a_position, 0.0, 1.0);
  }
</script>
<script type="x-shader/x-fragment" id="fragment-shader">
  precision mediump float;
  
  uniform vec2 u_resolution;
  uniform vec2 u_center;
  uniform float u_zoom;
  uniform int u_maxIterations;
  uniform float u_rotation;
  uniform float u_escapeRadius;
  uniform float u_colorOffset;
  uniform float u_colorSpeed;
  uniform float u_colorIntensity;
  uniform int u_juliaMode;
  uniform vec2 u_juliaC;
  uniform int u_colorPalette;
  uniform vec2 u_juliaC2; // Second fractal layer Julia C
  uniform vec2 u_juliaC3; // Third fractal layer Julia C
  
  varying vec2 v_uv;
  
  // Color palette functions
  vec3 paletteRainbow(float t) {
    return vec3(
      0.5 + 0.5 * cos(3.0 + t * u_colorSpeed + u_colorOffset),
      0.5 + 0.5 * cos(2.0 + t * u_colorSpeed + u_colorOffset),
      0.5 + 0.5 * cos(1.0 + t * u_colorSpeed + u_colorOffset)
    );
  }
  
  vec3 paletteFire(float t) {
    return vec3(
      t * u_colorIntensity,
      t * t * u_colorIntensity * 0.5,
      t * t * t * u_colorIntensity * 0.1
    );
  }
  
  vec3 paletteOcean(float t) {
    return vec3(
      0.1 + 0.3 * sin(t * u_colorSpeed + u_colorOffset),
      0.3 + 0.5 * sin(t * u_colorSpeed + u_colorOffset + 1.0),
      0.7 + 0.3 * sin(t * u_colorSpeed + u_colorOffset + 2.0)
    );
  }
  
  vec3 paletteForest(float t) {
    return vec3(
      0.1 + 0.2 * sin(t * u_colorSpeed + u_colorOffset),
      0.4 + 0.4 * sin(t * u_colorSpeed + u_colorOffset + 1.5),
      0.2 + 0.2 * sin(t * u_colorSpeed + u_colorOffset + 0.5)
    );
  }
  
  vec3 paletteSunset(float t) {
    return vec3(
      0.8 + 0.2 * cos(t * u_colorSpeed + u_colorOffset),
      0.4 + 0.3 * cos(t * u_colorSpeed + u_colorOffset + 1.0),
      0.2 + 0.2 * cos(t * u_colorSpeed + u_colorOffset + 2.0)
    );
  }
  
  vec3 paletteMonochrome(float t) {
    float gray = 0.5 + 0.5 * sin(t * u_colorSpeed + u_colorOffset);
    return vec3(gray * u_colorIntensity);
  }
  
  vec3 paletteGreen(float t) {
    return vec3(
      0.1 + 0.2 * sin(t * u_colorSpeed + u_colorOffset),
      0.6 + 0.4 * sin(t * u_colorSpeed + u_colorOffset + 1.0),
      0.2 + 0.3 * sin(t * u_colorSpeed + u_colorOffset + 0.5)
    );
  }
  
  vec3 paletteBlue(float t) {
    return vec3(
      0.1 + 0.2 * sin(t * u_colorSpeed + u_colorOffset),
      0.2 + 0.3 * sin(t * u_colorSpeed + u_colorOffset + 1.0),
      0.7 + 0.3 * sin(t * u_colorSpeed + u_colorOffset + 2.0)
    );
  }
  
  vec3 getColor(float t, int palette) {
    if (palette == 0) return paletteRainbow(t);
    else if (palette == 1) return paletteFire(t);
    else if (palette == 2) return paletteOcean(t);
    else if (palette == 3) return paletteForest(t);
    else if (palette == 4) return paletteSunset(t);
    else if (palette == 5) return paletteMonochrome(t);
    else if (palette == 6) return paletteGreen(t);
    else if (palette == 7) return paletteBlue(t);
    else return paletteMonochrome(t);
  }
  
  // Compute fractal for given Julia C constant
  // Returns: x = normalized iterations (0-1), y = 1.0 if inside set, 0.0 if outside
  vec2 computeFractal(vec2 c, vec2 juliaConstant) {
    vec2 z;
    vec2 constant;
    if (u_juliaMode == 1) {
      z = c;
      constant = juliaConstant;
    } else {
      z = vec2(0.0);
      constant = c;
    }
    
    int iterations = 0;
    bool escaped = false;
    
    for (int i = 0; i < 256; i++) {
      if (i >= u_maxIterations) break;
      
      float x = (z.x * z.x - z.y * z.y) + constant.x;
      float y = (z.x * z.y * 2.0) + constant.y;
      z = vec2(x, y);
      
      if (dot(z, z) > u_escapeRadius * u_escapeRadius) {
        iterations = i;
        escaped = true;
        break;
      }
    }
    
    float t = float(iterations) / float(u_maxIterations);
    float isInside = escaped ? 0.0 : 1.0; // 1.0 if inside set (didn't escape)
    return vec2(t, isInside);
  }
  
  void main() {
    // Map pixel coordinates to complex plane
    vec2 c = (v_uv - 0.5) * 2.0;
    c.x *= u_resolution.x / u_resolution.y; // Aspect ratio correction
    
    // Apply rotation
    float cosR = cos(u_rotation);
    float sinR = sin(u_rotation);
    c = vec2(c.x * cosR - c.y * sinR, c.x * sinR + c.y * cosR);
    
    // Apply zoom and center
    c = c / u_zoom + u_center;
    
    // Compute fractals for all three layers
    vec2 result1 = computeFractal(c, u_juliaC);
    vec2 result2 = computeFractal(c, u_juliaC2);
    vec2 result3 = computeFractal(c, u_juliaC3);
    
    float t1 = result1.x;
    float t2 = result2.x;
    float t3 = result3.x;
    float inside1 = result1.y;
    float inside2 = result2.y;
    float inside3 = result3.y;
    
    // Get colors for each layer
    vec3 color1 = getColor(t1, u_colorPalette); // Main layer (Fire)
    vec3 color2 = getColor(t2, 6); // Green palette
    vec3 color3 = getColor(t3, 7); // Blue palette
    
    // Blend layers with opacity (only render outside the set)
    vec3 finalColor = vec3(0.0);
    
    // Main layer (100% opacity)
    if (inside1 < 0.5) {
      finalColor += color1;
    }
    
    // Second layer (33% opacity, green)
    if (inside2 < 0.5) {
      finalColor += color2 * 0.33;
    }
    
    // Third layer (33% opacity, blue)
    if (inside3 < 0.5) {
      finalColor += color3 * 0.33;
    }
    
    // Clamp to prevent over-brightening
    finalColor = clamp(finalColor, 0.0, 1.0);
    
    gl_FragColor = vec4(finalColor, 1.0);
  }
</script>
<script>
const canvas = document.querySelector("canvas");

const gl = getRenderingContext();
let source = document.querySelector("#vertex-shader").innerHTML;
const vertexShader = gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vertexShader, source);
gl.compileShader(vertexShader);

source = document.querySelector("#fragment-shader").innerHTML;
const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fragmentShader, source);
gl.compileShader(fragmentShader);
const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);
gl.detachShader(program, vertexShader);
gl.detachShader(program, fragmentShader);
gl.deleteShader(vertexShader);
gl.deleteShader(fragmentShader);
if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
  const linkErrLog = gl.getProgramInfoLog(program);
  cleanup();
  document.querySelector("p").textContent =
    `Shader program did not link successfully. Error log: ${linkErrLog}`;
  throw new Error("Program failed to link");
}

let buffer;
initializeAttributes();

// Get uniform locations
const resolutionLocation = gl.getUniformLocation(program, "u_resolution");
const centerLocation = gl.getUniformLocation(program, "u_center");
const zoomLocation = gl.getUniformLocation(program, "u_zoom");
const maxIterationsLocation = gl.getUniformLocation(program, "u_maxIterations");
const rotationLocation = gl.getUniformLocation(program, "u_rotation");
const escapeRadiusLocation = gl.getUniformLocation(program, "u_escapeRadius");
const colorOffsetLocation = gl.getUniformLocation(program, "u_colorOffset");
const colorSpeedLocation = gl.getUniformLocation(program, "u_colorSpeed");
const colorIntensityLocation = gl.getUniformLocation(program, "u_colorIntensity");
const juliaModeLocation = gl.getUniformLocation(program, "u_juliaMode");
const juliaCLocation = gl.getUniformLocation(program, "u_juliaC");
const juliaC2Location = gl.getUniformLocation(program, "u_juliaC2");
const juliaC3Location = gl.getUniformLocation(program, "u_juliaC3");
const colorPaletteLocation = gl.getUniformLocation(program, "u_colorPalette");

// Mandelbrot parameters (mutable for UI controls)
let center = [-0.5, 0.0]; // Default center of Mandelbrot set
let zoom = 1.0;
let maxIterations = 100;
let rotation = 0.0;
let escapeRadius = 4.0;
let colorOffset = 0.0;
let colorSpeed = 10.0;
let colorIntensity = 1.0;
let juliaMode = true; // Set Julia mode to true
let juliaC = [-1.2900, 0.1889]; // Set initial Julia C X to -1.2900
let colorPalette = 1; // Set to Fire palette

// Ease-in-out function for smooth animation
function easeInOut(t) {
  // Cubic ease-in-out: smooth acceleration and deceleration
  return t < 0.5
    ? 4 * t * t * t
    : 1 - Math.pow(-2 * t + 2, 3) / 2;
}

// Julia C X animation parameters
const juliaCXAnimation = {
  startValue: -1.2900,
  endValue: -1.0910,
  duration: 10000, // 10 seconds in milliseconds (one direction)
  startTime: Date.now()
};

// Julia C values for all three layers
let juliaC2 = [-1.2900, 0.1889]; // Second layer (green)
let juliaC3 = [-1.2900, 0.1889]; // Third layer (blue)

// Update Julia C X with ease-in-out animation (both directions) for all layers
function updateJuliaCXAnimation() {
  const currentTime = Date.now();
  const fullCycleDuration = juliaCXAnimation.duration * 2; // 20 seconds total (forward + backward)
  
  // Calculate progress for main layer (no offset)
  const elapsed1 = (currentTime - juliaCXAnimation.startTime) % fullCycleDuration;
  const cycleProgress1 = elapsed1 / fullCycleDuration;
  
  // Calculate progress for layer 2 (25% offset)
  const offset2 = fullCycleDuration * 0.25; // 25% of cycle = 5 seconds
  const elapsed2 = (currentTime - juliaCXAnimation.startTime + offset2) % fullCycleDuration;
  const cycleProgress2 = elapsed2 / fullCycleDuration;
  
  // Calculate progress for layer 3 (25% offset from layer 2, so 50% total)
  const offset3 = fullCycleDuration * 0.5; // 50% of cycle = 10 seconds
  const elapsed3 = (currentTime - juliaCXAnimation.startTime + offset3) % fullCycleDuration;
  const cycleProgress3 = elapsed3 / fullCycleDuration;
  
  // Helper function to calculate Julia C X from cycle progress
  function calculateJuliaCX(cycleProgress) {
    let progress;
    if (cycleProgress < 0.5) {
      // First half: forward (-1.2900 to -1.0910)
      progress = cycleProgress * 2; // 0 to 1
    } else {
      // Second half: backward (-1.0910 to -1.2900)
      progress = (1.0 - cycleProgress) * 2; // 1 to 0
    }
    
    // Apply ease-in-out easing
    const easedProgress = easeInOut(progress);
    
    // Interpolate Julia C X from startValue to endValue
    return juliaCXAnimation.startValue + 
      (juliaCXAnimation.endValue - juliaCXAnimation.startValue) * easedProgress;
  }
  
  // Update all three layers
  juliaC[0] = calculateJuliaCX(cycleProgress1);
  juliaC2[0] = calculateJuliaCX(cycleProgress2);
  juliaC3[0] = calculateJuliaCX(cycleProgress3);
  
  // Update the slider and display value (main layer only)
  const juliaXSlider = document.getElementById('juliaX');
  const juliaXValue = document.getElementById('juliaXValue');
  if (juliaXSlider && juliaXValue) {
    juliaXSlider.value = juliaC[0];
    juliaXValue.textContent = juliaC[0].toFixed(4);
  }
}

// Initialize UI controls
function initializeControls() {
  const centerXSlider = document.getElementById('centerX');
  const centerYSlider = document.getElementById('centerY');
  const zoomSlider = document.getElementById('zoom');
  const maxIterationsSlider = document.getElementById('maxIterations');
  const rotationSlider = document.getElementById('rotation');
  const escapeRadiusSlider = document.getElementById('escapeRadius');
  const colorOffsetSlider = document.getElementById('colorOffset');
  const colorSpeedSlider = document.getElementById('colorSpeed');
  const colorIntensitySlider = document.getElementById('colorIntensity');
  const juliaModeCheckbox = document.getElementById('juliaMode');
  const juliaXSlider = document.getElementById('juliaX');
  const juliaYSlider = document.getElementById('juliaY');
  const colorPaletteSelect = document.getElementById('colorPalette');
  const resetBtn = document.getElementById('resetBtn');
  
  const centerXValue = document.getElementById('centerXValue');
  const centerYValue = document.getElementById('centerYValue');
  const zoomValue = document.getElementById('zoomValue');
  const maxIterationsValue = document.getElementById('maxIterationsValue');
  const rotationValue = document.getElementById('rotationValue');
  const escapeRadiusValue = document.getElementById('escapeRadiusValue');
  const colorOffsetValue = document.getElementById('colorOffsetValue');
  const colorSpeedValue = document.getElementById('colorSpeedValue');
  const colorIntensityValue = document.getElementById('colorIntensityValue');
  const juliaModeValue = document.getElementById('juliaModeValue');
  const juliaXValue = document.getElementById('juliaXValue');
  const juliaYValue = document.getElementById('juliaYValue');
  
  const juliaControls = document.getElementById('juliaControls');
  const juliaControls2 = document.getElementById('juliaControls2');
  
  // Update center X
  centerXSlider.addEventListener('input', (e) => {
    center[0] = parseFloat(e.target.value);
    centerXValue.textContent = center[0].toFixed(3);
  });
  
  // Update center Y
  centerYSlider.addEventListener('input', (e) => {
    center[1] = parseFloat(e.target.value);
    centerYValue.textContent = center[1].toFixed(3);
  });
  
  // Update zoom
  zoomSlider.addEventListener('input', (e) => {
    zoom = parseFloat(e.target.value);
    zoomValue.textContent = zoom.toFixed(2);
  });
  
  // Update max iterations
  maxIterationsSlider.addEventListener('input', (e) => {
    maxIterations = parseInt(e.target.value);
    maxIterationsValue.textContent = maxIterations;
  });
  
  // Update rotation
  rotationSlider.addEventListener('input', (e) => {
    rotation = parseFloat(e.target.value);
    rotationValue.textContent = rotation.toFixed(2);
  });
  
  // Update escape radius
  escapeRadiusSlider.addEventListener('input', (e) => {
    escapeRadius = parseFloat(e.target.value);
    escapeRadiusValue.textContent = escapeRadius.toFixed(1);
  });
  
  // Update color offset
  colorOffsetSlider.addEventListener('input', (e) => {
    colorOffset = parseFloat(e.target.value);
    colorOffsetValue.textContent = colorOffset.toFixed(1);
  });
  
  // Update color speed
  colorSpeedSlider.addEventListener('input', (e) => {
    colorSpeed = parseFloat(e.target.value);
    colorSpeedValue.textContent = colorSpeed;
  });
  
  // Update color intensity
  colorIntensitySlider.addEventListener('input', (e) => {
    colorIntensity = parseFloat(e.target.value);
    colorIntensityValue.textContent = colorIntensity.toFixed(1);
  });
  
  // Update Julia mode
  juliaModeCheckbox.addEventListener('change', (e) => {
    juliaMode = e.target.checked;
    juliaModeValue.textContent = juliaMode ? 'On' : 'Off';
    juliaControls.style.display = juliaMode ? 'block' : 'none';
    juliaControls2.style.display = juliaMode ? 'block' : 'none';
  });
  
  // Set Julia mode to true and show controls on initialization
  juliaModeCheckbox.checked = true;
  juliaMode = true;
  juliaModeValue.textContent = 'On';
  juliaControls.style.display = 'block';
  juliaControls2.style.display = 'block';
  
  // Set color palette to Fire
  colorPaletteSelect.value = colorPalette;
  
  // Update Julia C X
  juliaXSlider.addEventListener('input', (e) => {
    juliaC[0] = parseFloat(e.target.value);
    juliaXValue.textContent = juliaC[0].toFixed(4);
  });
  
  // Update Julia C Y
  juliaYSlider.addEventListener('input', (e) => {
    juliaC[1] = parseFloat(e.target.value);
    juliaYValue.textContent = juliaC[1].toFixed(4);
  });
  
  // Update color palette
  colorPaletteSelect.addEventListener('change', (e) => {
    colorPalette = parseInt(e.target.value);
  });
  
  // Reset button
  resetBtn.addEventListener('click', () => {
    center = [-0.5, 0.0];
    zoom = 1.0;
    maxIterations = 100;
    rotation = 0.0;
    escapeRadius = 4.0;
    colorOffset = 0.0;
    colorSpeed = 10.0;
    colorIntensity = 1.0;
    juliaMode = false;
    juliaC = [-0.7269, 0.1889];
    colorPalette = 0;
    
    centerXSlider.value = center[0];
    centerYSlider.value = center[1];
    zoomSlider.value = zoom;
    maxIterationsSlider.value = maxIterations;
    rotationSlider.value = rotation;
    escapeRadiusSlider.value = escapeRadius;
    colorOffsetSlider.value = colorOffset;
    colorSpeedSlider.value = colorSpeed;
    colorIntensitySlider.value = colorIntensity;
    juliaModeCheckbox.checked = juliaMode;
    juliaXSlider.value = juliaC[0];
    juliaYSlider.value = juliaC[1];
    colorPaletteSelect.value = colorPalette;
    
    centerXValue.textContent = center[0].toFixed(3);
    centerYValue.textContent = center[1].toFixed(3);
    zoomValue.textContent = zoom.toFixed(2);
    maxIterationsValue.textContent = maxIterations;
    rotationValue.textContent = rotation.toFixed(2);
    escapeRadiusValue.textContent = escapeRadius.toFixed(1);
    colorOffsetValue.textContent = colorOffset.toFixed(1);
    colorSpeedValue.textContent = colorSpeed;
    colorIntensityValue.textContent = colorIntensity.toFixed(1);
    juliaModeValue.textContent = juliaMode ? 'On' : 'Off';
    juliaXValue.textContent = juliaC[0].toFixed(4);
    juliaYValue.textContent = juliaC[1].toFixed(4);
    
    juliaControls.style.display = juliaMode ? 'block' : 'none';
    juliaControls2.style.display = juliaMode ? 'block' : 'none';
  });
}

initializeControls();

function render() {
  // Update Julia C X animation
  updateJuliaCXAnimation();
  
  // Update viewport if canvas size changed
  const width = canvas.clientWidth;
  const height = canvas.clientHeight;
  if (canvas.width !== width || canvas.height !== height) {
    canvas.width = width;
    canvas.height = height;
    gl.viewport(0, 0, width, height);
  }
  
  // Clear and draw
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.useProgram(program);
  
  // Set uniforms
  gl.uniform2f(resolutionLocation, width, height);
  gl.uniform2f(centerLocation, center[0], center[1]);
  gl.uniform1f(zoomLocation, zoom);
  gl.uniform1i(maxIterationsLocation, maxIterations);
  gl.uniform1f(rotationLocation, rotation);
  gl.uniform1f(escapeRadiusLocation, escapeRadius);
  gl.uniform1f(colorOffsetLocation, colorOffset);
  gl.uniform1f(colorSpeedLocation, colorSpeed);
  gl.uniform1f(colorIntensityLocation, colorIntensity);
  gl.uniform1i(juliaModeLocation, juliaMode ? 1 : 0);
  gl.uniform2f(juliaCLocation, juliaC[0], juliaC[1]);
  gl.uniform2f(juliaC2Location, juliaC2[0], juliaC2[1]);
  gl.uniform2f(juliaC3Location, juliaC3[0], juliaC3[1]);
  gl.uniform1i(colorPaletteLocation, colorPalette);
  
  // Draw full-screen quad (2 triangles = 6 vertices)
  gl.drawArrays(gl.TRIANGLES, 0, 6);
  
  requestAnimationFrame(render);
}

render();

function getRenderingContext() {
  canvas.width = canvas.clientWidth;
  canvas.height = canvas.clientHeight;
  const gl = canvas.getContext("webgl");
  gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
  gl.clearColor(0.0, 0.0, 0.0, 1.0);
  gl.clear(gl.COLOR_BUFFER_BIT);
  return gl;
}

function initializeAttributes() {
  // Define full-screen quad as two triangles (covering -1 to 1 in both dimensions)
  const quadVertices = new Float32Array([
    // First triangle
    -1.0, -1.0,
     1.0, -1.0,
    -1.0,  1.0,
    // Second triangle
    -1.0,  1.0,
     1.0, -1.0,
     1.0,  1.0
  ]);
  
  // Get the attribute location
  const positionLocation = gl.getAttribLocation(program, "a_position");
  
  // Create and bind buffer
  buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, quadVertices, gl.STATIC_DRAW);
  
  // Enable and set up the attribute
  gl.enableVertexAttribArray(positionLocation);
  gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
}

function cleanup() {
  gl.useProgram(null);
  if (buffer) {
    gl.deleteBuffer(buffer);
  }
  if (program) {
    gl.deleteProgram(program);
  }
}


</script>
</body>
</html>