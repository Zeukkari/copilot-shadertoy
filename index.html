<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hello World! Hello GLSL!</title>
<link rel="stylesheet" href="style.css">

</head>
<body>
<p>Hello World! Hello GLSL!</p>
<canvas>Your browser does not seem to support HTML canvas.</canvas>
<div id="controls" class="controls-panel">
  <h3>Multi-Fractal Animation</h3>
  <p style="color: #aaa; font-size: 11px; margin-bottom: 15px;">
    4 animated fractal layers with additive blending
  </p>
  <button id="play" class="audio-btn">Play Note</button>
</div>
<script type="x-shader/x-vertex" id="vertex-shader">
  attribute vec2 a_position;
  varying vec2 v_uv;
  
  void main() {
    v_uv = a_position * 0.5 + 0.5; // Convert from -1..1 to 0..1
    gl_Position = vec4(a_position, 0.0, 1.0);
  }
</script>
<script type="x-shader/x-fragment" id="fragment-shader">
  precision mediump float;
  
  uniform vec2 u_resolution;
  uniform float u_time;
  uniform float u_beatTime;
  uniform float u_beatPhase;
  
  varying vec2 v_uv;
  
  // Mandelbrot computation function
  float mandelbrot(vec2 uv, vec2 center, float zoom, float rotation, int maxIter) {
    vec2 c = (uv - 0.5) * 2.0;
    c.x *= u_resolution.x / u_resolution.y;
    
    // Apply rotation
    float cosR = cos(rotation);
    float sinR = sin(rotation);
    c = vec2(c.x * cosR - c.y * sinR, c.x * sinR + c.y * cosR);
    
    // Apply zoom and center
    c = c / zoom + center;
    
    vec2 z = vec2(0.0);
    int iterations = 0;
    
    for (int i = 0; i < 256; i++) {
      if (i >= maxIter) break;
      
      float x = (z.x * z.x - z.y * z.y) + c.x;
      float y = (z.x * z.y * 2.0) + c.y;
      z = vec2(x, y);
      
      if (dot(z, z) > 4.0) {
        iterations = i;
        break;
      }
    }
    
    if (iterations == maxIter) {
      return 0.0; // Return 0.0 for inside the set (becomes white after inversion)
    }
    
    return float(iterations) / float(maxIter);
  }
  
  // Simple noise function
  float noise(vec2 p) {
    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
  }
  
  // Screen curvature/distortion with hallucinogenic warping
  vec2 crtDistort(vec2 uv) {
    uv = (uv - 0.5) * 2.0;
    
    // Radial distortion with beat sync
    float dist = length(uv);
    float beatDistortion = 1.0 + 0.15 * (uv.x * uv.x + uv.y * uv.y);
    beatDistortion += u_beatPhase * 0.1; // Pulse on beat
    uv *= beatDistortion;
    
    // Psychedelic wave distortion (slowed down) with beat sync
    float waveIntensity = 0.1 + u_beatPhase * 0.05;
    float waveX = sin(uv.y * 3.0 + u_time * 0.5) * waveIntensity;
    float waveY = cos(uv.x * 3.0 + u_time * 0.375) * waveIntensity;
    uv += vec2(waveX, waveY);
    
    // Spiral distortion (slowed down) with beat sync
    float angle = atan(uv.y, uv.x) + dist * 2.0 + u_time * 0.25;
    float spiral = sin(angle * 3.0) * (0.05 + u_beatPhase * 0.03);
    uv += vec2(cos(angle), sin(angle)) * spiral;
    
    return (uv + 1.0) * 0.5;
  }
  
  void main() {
    // Apply CRT screen distortion
    vec2 distortedUV = crtDistort(v_uv);
    
    // Enhanced chromatic aberration with psychedelic separation and beat sync
    float aberration = 0.008 + 0.005 * sin(u_time * 0.75) + u_beatPhase * 0.01;
    vec2 offsetR = vec2(
      aberration * sin(u_time * 1.0 + distortedUV.y * 10.0 + u_beatPhase * 2.0),
      aberration * 0.5 * cos(u_time * 0.875 + distortedUV.x * 8.0)
    );
    vec2 offsetG = vec2(0.0, 0.0);
    vec2 offsetB = vec2(
      -aberration * sin(u_time * 1.0 + distortedUV.y * 10.0 + u_beatPhase * 2.0),
      -aberration * 0.5 * cos(u_time * 0.875 + distortedUV.x * 8.0)
    );
    
    // Sample fractal with different UV offsets for RGB channels
    vec2 uvR = distortedUV + offsetR;
    vec2 uvG = distortedUV + offsetG;
    vec2 uvB = distortedUV + offsetB;
    
    // Compute fractal for each channel
    vec3 finalColor = vec3(0.0);
    
    // Layer 1: Red/Orange fractal
    float t1 = u_time * 0.15;
    vec2 center1 = vec2(-0.5 + 0.2 * sin(t1), 0.0 + 0.2 * cos(t1 * 0.7));
    float zoom1 = 1.0 + 0.5 * sin(t1 * 0.5);
    float rot1 = t1 * 0.2;
    
    float m1R = mandelbrot(uvR, center1, zoom1, rot1, 80);
    float m1G = mandelbrot(uvG, center1, zoom1, rot1, 80);
    float m1B = mandelbrot(uvB, center1, zoom1, rot1, 80);
    
    vec3 color1 = vec3(
      0.8 + 0.2 * cos(m1R * 20.0 + t1),
      0.3 + 0.2 * sin(m1G * 15.0),
      0.1
    ) * vec3(m1R, m1G, m1B) * 0.6;
    finalColor += color1;
    
    // Layer 2: Cyan/Blue fractal
    float t2 = u_time * 0.2;
    vec2 center2 = vec2(-0.75 + 0.15 * cos(t2 * 0.8), 0.1 + 0.15 * sin(t2));
    float zoom2 = 1.2 + 0.3 * cos(t2 * 0.6);
    float rot2 = -t2 * 0.15;
    
    float m2R = mandelbrot(uvR, center2, zoom2, rot2, 100);
    float m2G = mandelbrot(uvG, center2, zoom2, rot2, 100);
    float m2B = mandelbrot(uvB, center2, zoom2, rot2, 100);
    
    vec3 color2 = vec3(
      0.1,
      0.5 + 0.3 * cos(m2G * 18.0 + t2 * 2.0),
      0.9 + 0.1 * sin(m2B * 12.0)
    ) * vec3(m2R, m2G, m2B) * 0.5;
    finalColor += color2;
    
    // Layer 3: Green/Magenta fractal
    float t3 = u_time * 0.25;
    vec2 center3 = vec2(-0.2 + 0.1 * sin(t3 * 1.2), 0.8 + 0.1 * cos(t3 * 0.9));
    float zoom3 = 0.8 + 0.4 * sin(t3 * 0.7);
    float rot3 = t3 * 0.25;
    
    float m3R = mandelbrot(uvR, center3, zoom3, rot3, 90);
    float m3G = mandelbrot(uvG, center3, zoom3, rot3, 90);
    float m3B = mandelbrot(uvB, center3, zoom3, rot3, 90);
    
    vec3 color3 = vec3(
      0.2 + 0.3 * sin(m3R * 16.0),
      0.8 + 0.2 * cos(m3G * 14.0 + t3),
      0.4 + 0.3 * sin(m3B * 10.0)
    ) * vec3(m3R, m3G, m3B) * 0.4;
    finalColor += color3;
    
    // Layer 4: Purple/Yellow fractal
    float t4 = u_time * 0.125;
    vec2 center4 = vec2(0.0 + 0.12 * cos(t4 * 0.5), -0.5 + 0.12 * sin(t4 * 0.6));
    float zoom4 = 1.1 + 0.2 * cos(t4 * 0.4);
    float rot4 = -t4 * 0.1;
    
    float m4R = mandelbrot(uvR, center4, zoom4, rot4, 85);
    float m4G = mandelbrot(uvG, center4, zoom4, rot4, 85);
    float m4B = mandelbrot(uvB, center4, zoom4, rot4, 85);
    
    vec3 color4 = vec3(
      0.6 + 0.2 * cos(m4R * 22.0),
      0.3 + 0.2 * sin(m4G * 19.0),
      0.7 + 0.2 * cos(m4B * 17.0 + t4)
    ) * vec3(m4R, m4G, m4B) * 0.35;
    finalColor += color4;
    
    // Enhanced contrast and color enhancement with beat sync
    float contrastBoost = 0.75 - u_beatPhase * 0.1; // More contrast on beat
    finalColor = pow(finalColor, vec3(contrastBoost));
    
    // Intense color cycling/shifting (slowed down) with beat sync
    float colorShift = u_time * 0.125 + u_beatPhase * 0.5; // Shift colors on beat
    vec3 colorShiftVec = vec3(
      sin(colorShift),
      sin(colorShift + 2.094), // 120 degrees
      sin(colorShift + 4.189)  // 240 degrees
    ) * 0.3 + 0.7;
    finalColor *= colorShiftVec;
    
    // Beat-synced brightness pulse
    finalColor *= (1.0 + u_beatPhase * 0.3);
    
    // Increased saturation and contrast
    float luminance = dot(finalColor, vec3(0.299, 0.587, 0.114));
    float saturation = 1.8 + u_beatPhase * 0.4; // More saturation on beat
    finalColor = mix(vec3(luminance), finalColor, saturation);
    
    // Contrast boost with beat sync
    float contrast = 1.5 + u_beatPhase * 0.3;
    finalColor = (finalColor - 0.5) * contrast + 0.5;
    
    finalColor = clamp(finalColor, 0.0, 1.0);
    
    // CRT Effects
    vec2 screenUV = distortedUV;
    
    // Scanlines
    float scanline = sin(screenUV.y * u_resolution.y * 0.7) * 0.5 + 0.5;
    scanline = pow(scanline, 8.0);
    finalColor *= mix(0.95, 1.0, scanline);
    
    // Horizontal scanline flicker
    float flicker = 0.98 + 0.02 * sin(u_time * 30.0);
    finalColor *= flicker;
    
    // Vignette
    vec2 vignetteUV = (screenUV - 0.5) * 2.0;
    float vignette = 1.0 - dot(vignetteUV, vignetteUV) * 0.3;
    finalColor *= vignette;
    
    // Static noise
    float staticNoise = noise(vec2(screenUV * u_resolution + u_time * 10.0));
    finalColor += (staticNoise - 0.5) * 0.02;
    
    // Intense screen warp/glitch with hallucinations (slowed down)
    float glitch = step(0.95, noise(vec2(u_time * 0.25, screenUV.y * 10.0)));
    float glitch2 = step(0.97, noise(vec2(u_time * 0.175, screenUV.x * 15.0)));
    
    // Color channel swapping
    if (glitch > 0.5) {
      vec3 temp = finalColor;
      finalColor.r = temp.b;
      finalColor.b = temp.g;
      finalColor.g = temp.r;
    }
    
    // Intense color shifts during glitches
    finalColor = mix(finalColor, finalColor * vec3(1.5, 0.6, 1.8), glitch * 0.5);
    finalColor = mix(finalColor, finalColor * vec3(0.7, 1.6, 0.9), glitch2 * 0.4);
    
    // Enhanced color bleed with time-based variation (slowed down)
    float bleedAmount = 0.2 + 0.1 * sin(u_time * 0.5);
    finalColor.r = mix(finalColor.r, finalColor.g, bleedAmount);
    finalColor.b = mix(finalColor.b, finalColor.g, bleedAmount);
    
    // Radial color gradients (kaleidoscope effect) - slowed down
    vec2 center = screenUV - 0.5;
    float radial = length(center);
    float angle = atan(center.y, center.x) + u_time * 0.25;
    vec3 radialColor = vec3(
      0.5 + 0.5 * sin(angle * 2.0 + radial * 10.0),
      0.5 + 0.5 * sin(angle * 2.0 + radial * 10.0 + 2.094),
      0.5 + 0.5 * sin(angle * 2.0 + radial * 10.0 + 4.189)
    );
    finalColor = mix(finalColor, finalColor * radialColor, 0.15);
    
    // Final clamp
    finalColor = clamp(finalColor, 0.0, 1.0);
    
    // Check if we're in the background (inside the set - very dark areas)
    float intensity = dot(finalColor, vec3(0.299, 0.587, 0.114));
    if (intensity < 0.1) {
      // Pure black background (becomes white after inversion)
      finalColor = vec3(0.0);
    } else {
      // Invert colors for fractal areas (black becomes white)
      finalColor = 1.0 - finalColor;
    }
    
    gl_FragColor = vec4(finalColor, 1.0);
  }
</script>
<script src="script.js"></script>
</body>
</html>