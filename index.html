<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hello World! Hello GLSL!</title>
<link rel="stylesheet" href="style.css">

</head>
<body>
<p>Hello World! Hello GLSL!</p>
<canvas>Your browser does not seem to support HTML canvas.</canvas>
<div id="controls" class="controls-panel">
  <h3>Fractal Controls</h3>
  <div class="control-group">
    <label for="centerX">Center X:</label>
    <input type="range" id="centerX" min="-2" max="1" step="0.001" value="-0.5">
    <span class="value-display" id="centerXValue">-0.5</span>
  </div>
  <div class="control-group">
    <label for="centerY">Center Y:</label>
    <input type="range" id="centerY" min="-1.5" max="1.5" step="0.001" value="0.0">
    <span class="value-display" id="centerYValue">0.0</span>
  </div>
  <div class="control-group">
    <label for="zoom">Zoom:</label>
    <input type="range" id="zoom" min="0.1" max="10" step="0.000001" value="1.0">
    <span class="value-display" id="zoomValue">1.0</span>
  </div>
  <div class="control-group">
    <label for="maxIterations">Max Iterations:</label>
    <input type="range" id="maxIterations" min="10" max="500" step="10" value="100">
    <span class="value-display" id="maxIterationsValue">100</span>
  </div>
  <button id="resetBtn" class="reset-btn">Reset to Default</button>
</div>
<script type="x-shader/x-vertex" id="vertex-shader">
  attribute vec2 a_position;
  varying vec2 v_uv;
  
  void main() {
    v_uv = a_position * 0.5 + 0.5; // Convert from -1..1 to 0..1
    gl_Position = vec4(a_position, 0.0, 1.0);
  }
</script>
<script type="x-shader/x-fragment" id="fragment-shader">
  precision mediump float;
  
  uniform vec2 u_resolution;
  uniform vec2 u_center;
  uniform float u_zoom;
  uniform int u_maxIterations;
  
  varying vec2 v_uv;
  
  void main() {
    // Map pixel coordinates to complex plane
    vec2 c = (v_uv - 0.5) * 2.0;
    c.x *= u_resolution.x / u_resolution.y; // Aspect ratio correction
    c = c / u_zoom + u_center;
    
    // Mandelbrot iteration: z = z^2 + c
    vec2 z = vec2(0.0);
    int iterations = 0;
    
    for (int i = 0; i < 256; i++) {
      if (i >= u_maxIterations) break;
      
      // z = z^2 + c
      float x = (z.x * z.x - z.y * z.y) + c.x;
      float y = (z.x * z.y * 2.0) + c.y;
      z = vec2(x, y);
      
      // Check if escaped
      if (dot(z, z) > 4.0) {
        iterations = i;
        break;
      }
    }
    
    // Color based on iterations
    float t = float(iterations) / float(u_maxIterations);
    
    if (iterations == u_maxIterations) {
      // Inside the set - black
      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    } else {
      // Outside the set - colorful gradient
      vec3 color = vec3(
        0.5 + 0.5 * cos(3.0 + t * 10.0),
        0.5 + 0.5 * cos(2.0 + t * 10.0),
        0.5 + 0.5 * cos(1.0 + t * 10.0)
      );
      gl_FragColor = vec4(color, 1.0);
    }
  }
</script>
<script>
const canvas = document.querySelector("canvas");

const gl = getRenderingContext();
let source = document.querySelector("#vertex-shader").innerHTML;
const vertexShader = gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vertexShader, source);
gl.compileShader(vertexShader);

source = document.querySelector("#fragment-shader").innerHTML;
const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fragmentShader, source);
gl.compileShader(fragmentShader);
const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);
gl.detachShader(program, vertexShader);
gl.detachShader(program, fragmentShader);
gl.deleteShader(vertexShader);
gl.deleteShader(fragmentShader);
if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
  const linkErrLog = gl.getProgramInfoLog(program);
  cleanup();
  document.querySelector("p").textContent =
    `Shader program did not link successfully. Error log: ${linkErrLog}`;
  throw new Error("Program failed to link");
}

let buffer;
initializeAttributes();

// Get uniform locations
const resolutionLocation = gl.getUniformLocation(program, "u_resolution");
const centerLocation = gl.getUniformLocation(program, "u_center");
const zoomLocation = gl.getUniformLocation(program, "u_zoom");
const maxIterationsLocation = gl.getUniformLocation(program, "u_maxIterations");

// Mandelbrot parameters (mutable for UI controls)
let center = [-0.5, 0.0]; // Default center of Mandelbrot set
let zoom = 1.0;
let maxIterations = 100;

// Initialize UI controls
function initializeControls() {
  const centerXSlider = document.getElementById('centerX');
  const centerYSlider = document.getElementById('centerY');
  const zoomSlider = document.getElementById('zoom');
  const maxIterationsSlider = document.getElementById('maxIterations');
  const resetBtn = document.getElementById('resetBtn');
  
  const centerXValue = document.getElementById('centerXValue');
  const centerYValue = document.getElementById('centerYValue');
  const zoomValue = document.getElementById('zoomValue');
  const maxIterationsValue = document.getElementById('maxIterationsValue');
  
  // Update center X
  centerXSlider.addEventListener('input', (e) => {
    center[0] = parseFloat(e.target.value);
    centerXValue.textContent = center[0].toFixed(3);
  });
  
  // Update center Y
  centerYSlider.addEventListener('input', (e) => {
    center[1] = parseFloat(e.target.value);
    centerYValue.textContent = center[1].toFixed(3);
  });
  
  // Update zoom (using logarithmic scale for better control)
  zoomSlider.addEventListener('input', (e) => {
    // Convert linear slider value (0.1-1000) to logarithmic scale
    const sliderValue = parseFloat(e.target.value);
    zoom = sliderValue;
    zoomValue.textContent = zoom.toFixed(2);
  });
  
  // Update max iterations
  maxIterationsSlider.addEventListener('input', (e) => {
    maxIterations = parseInt(e.target.value);
    maxIterationsValue.textContent = maxIterations;
  });
  
  // Reset button
  resetBtn.addEventListener('click', () => {
    center = [-0.5, 0.0];
    zoom = 1.0;
    maxIterations = 100;
    
    centerXSlider.value = center[0];
    centerYSlider.value = center[1];
    zoomSlider.value = zoom;
    maxIterationsSlider.value = maxIterations;
    
    centerXValue.textContent = center[0].toFixed(3);
    centerYValue.textContent = center[1].toFixed(3);
    zoomValue.textContent = zoom.toFixed(2);
    maxIterationsValue.textContent = maxIterations;
  });
}

initializeControls();

function render() {
  // Update viewport if canvas size changed
  const width = canvas.clientWidth;
  const height = canvas.clientHeight;
  if (canvas.width !== width || canvas.height !== height) {
    canvas.width = width;
    canvas.height = height;
    gl.viewport(0, 0, width, height);
  }
  
  // Clear and draw
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.useProgram(program);
  
  // Set uniforms
  gl.uniform2f(resolutionLocation, width, height);
  gl.uniform2f(centerLocation, center[0], center[1]);
  gl.uniform1f(zoomLocation, zoom);
  gl.uniform1i(maxIterationsLocation, maxIterations);
  
  // Draw full-screen quad (2 triangles = 6 vertices)
  gl.drawArrays(gl.TRIANGLES, 0, 6);
  
  requestAnimationFrame(render);
}

render();

function getRenderingContext() {
  canvas.width = canvas.clientWidth;
  canvas.height = canvas.clientHeight;
  const gl = canvas.getContext("webgl");
  gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
  gl.clearColor(0.0, 0.0, 0.0, 1.0);
  gl.clear(gl.COLOR_BUFFER_BIT);
  return gl;
}

function initializeAttributes() {
  // Define full-screen quad as two triangles (covering -1 to 1 in both dimensions)
  const quadVertices = new Float32Array([
    // First triangle
    -1.0, -1.0,
     1.0, -1.0,
    -1.0,  1.0,
    // Second triangle
    -1.0,  1.0,
     1.0, -1.0,
     1.0,  1.0
  ]);
  
  // Get the attribute location
  const positionLocation = gl.getAttribLocation(program, "a_position");
  
  // Create and bind buffer
  buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, quadVertices, gl.STATIC_DRAW);
  
  // Enable and set up the attribute
  gl.enableVertexAttribArray(positionLocation);
  gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
}

function cleanup() {
  gl.useProgram(null);
  if (buffer) {
    gl.deleteBuffer(buffer);
  }
  if (program) {
    gl.deleteProgram(program);
  }
}


</script>
</body>
</html>
